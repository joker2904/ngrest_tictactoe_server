// This file generated by ngrestcg
// For more information, please visit: https://github.com/loentar/ngrest

#include "tictacserver.h"
#include <unordered_map>
#include <vector>
#include <mutex>
#include <utility>
#include <iostream>

using namespace std;

/* singleton class to manage the game and players */
class GameManager
{
  private:
    int numOfPlayers; 
    int numOfGames;
    mutex mutex_player_operation;   
    mutex mutex_game_operation;    
    vector<mutex> game_lock;
    vector<mutex> player_lock;
    unordered_map<int, vector<vector<char>> > Boards;
    unordered_map<int,int> PlayerData;
    unordered_map<int, vector<int> > GamePlayers;
    
    GameManager()
    {
        numOfPlayers = 0;
        numOfGames = 0;
    }
  public:
    static GameManager* instance;

    /* get instance member pointer to singleton class */
    static GameManager* inst()
    {
        if(instance == NULL)
          instance = new GameManager();        
        return instance;
    }  

    /* Create a new player with a new id. Write it to the player file */
    int create_new_player()
    {
      mutex_player_operation.lock();
      ++numOfPlayers;
      PlayerData[numOfPlayers] = 0;
      mutex_player_operation.unlock();
      return numOfPlayers;
    }

    /* Fetch the player data */
    unordered_map<int,int> players()
    {
      return PlayerData;
    }

    /* Fetch the player if from a particular gameid */
    int GetPlayerFromGame(int gameid,int status)
    {
      return GamePlayers[gameid][status];
    }

    /* Create a new game and set the game board. Add it to the map of all games being played currently */
    int CreateNewGame()
    {
      vector<char> temp = {'.','.','.'};
      vector<vector<char>> board(3,temp);
      mutex_game_operation.lock();
      Boards[++numOfGames] = board; // initialize an empty board, and assign it to game id 
      /* Each gameid has 4 variables. 0: id of player 1. 1: id of player 2.  2: id of player who played last 
         3. game status (-1: currently played, 0: game over, 0-th index player won, 1: game over, 1-th index player won, 
                          2: game over, draw) 
      */
      GamePlayers[numOfGames] = {-1,-1,-1,-1};
      mutex_game_operation.unlock();
      return numOfGames; 
    }

    /* Fetch all the list of games being played currently and the game boards */
    unordered_map<int, vector<vector<char>> > GetAllGames()
    {
      return Boards;
    }

    /* Fetch all the list of games being played currently and the game status */
    unordered_map<int, vector<int> > GetAllGamesStatus()
    {
      return GamePlayers;
    }
    
    /*  check if move is possible for this board, by playerid. 
        Assign X or O to current position.
        The Gameplayers 0th index will badge a X, and GamePlayers 1th index will badge a O.  
    */
    pair<bool,char> CheckMove(int gameid,int playerid)
    {
      if(playerid <=0 || playerid > numOfPlayers)
         return pair<bool,char>(false,'\0');
      if(GamePlayers[gameid][0] == -1 && GamePlayers[gameid][1] == -1)
      {
        GamePlayers[gameid][0] = playerid;
        //GamePlayers[gameid][2] = playerid;
        return pair<bool,char>(true,'X');
      }
      if(GamePlayers[gameid][0] > -1 && GamePlayers[gameid][1] == -1 && playerid != GamePlayers[gameid][2])
      {
        GamePlayers[gameid][1] = playerid;
        //GamePlayers[gameid][2] = playerid;
        return pair<bool,char>(true,'O');
      }
      if(GamePlayers[gameid][0] > -1 && 
         GamePlayers[gameid][1] > -1 && 
         (playerid == GamePlayers[gameid][0] || playerid == GamePlayers[gameid][1]) &&
          playerid != GamePlayers[gameid][2]
        )
      {
        //GamePlayers[gameid][2] = playerid;
        char move;
        if(GamePlayers[gameid][0] == playerid)
           move = 'X';
        else if(GamePlayers[gameid][1] == playerid)
           move = 'O';
        return pair<bool,char>(true,move);
      }
      return pair<bool,char>(false,'\0');
    }

    /* Check the game status on the board. If it is a win the return winner index. If draw, return 2. If it is a normal move return -1 */
    int CheckGameBoardStatus(int gameid,char playermove)
    {
      int playerindex = (playermove=='X')? 0:1;
      vector<vector<char>>& board = Boards[gameid];
      /* check for all possible winning positions */
      if(board[0][0] == playermove && board[0][1] == playermove && board[0][2] == playermove ) 
          return playerindex;
      if(board[1][0] == playermove && board[1][1] == playermove && board[1][2] == playermove ) 
          return playerindex;
      if(board[2][0] == playermove && board[2][1] == playermove && board[2][2] == playermove ) 
          return playerindex;
      if(board[0][0] == playermove && board[1][0] == playermove && board[2][0] == playermove ) 
          return playerindex;
      if(board[0][1] == playermove && board[1][1] == playermove && board[2][1] == playermove ) 
          return playerindex;
      if(board[0][2] == playermove && board[1][2] == playermove && board[2][2] == playermove ) 
          return playerindex;
      if(board[0][0] == playermove && board[1][1] == playermove && board[2][2] == playermove ) 
          return playerindex;
      if(board[2][0] == playermove && board[1][1] == playermove && board[0][2] == playermove ) 
          return playerindex;
      /* No winning position, check for draw */
      for(int i=0; i<3;++i)
        for(int j=0;j<3;++j)
          if(board[i][j] == '.')
              return -1;
      /* All positions are filled, nobody has won or lost, so game is a draw */
      return 2;
    }

    /* Implement the next nove on a game, for a playerid
       return: -1: succesful move, game can continue, 
                0: game over, player with index 0 won,
                1: game over, player with index 1 won, 
                2: game over, draw,
                3: move not possible. 
                4. Invalid user tried to make a move
    */  
    int makemove(int gameid,int playerid,int row,int col)
    {
       int status = 3;
       mutex_game_operation.lock();
       /* Check the move status, if it is possible */
       pair<bool,char> movestatus = CheckMove(gameid,playerid); /* get X or O according to the playerid */
       if(movestatus.first==false)
          status = 4;
       if( (GamePlayers[gameid][3] == -1) && movestatus.first==true && row>=1 && row<=3 && col>=1 && col<=3 && Boards[gameid][row-1][col-1] == '.')
       {        
           Boards[gameid][row-1][col-1] = movestatus.second; /* Put X or O according to the playerid */
           GamePlayers[gameid][2] = playerid; /* The player who played last on this board is playerid, so assign it.*/
           status = CheckGameBoardStatus(gameid,movestatus.second);            
           if(status >= 0) /* Check if game is over */
              GamePlayers[gameid][3] = status; /* Since game is over assign the winner if there, or draw*/                    
           if(status >=0 && status <= 1)
           {
            mutex_player_operation.lock();
            ++PlayerData[GamePlayers[gameid][status]];            
            mutex_player_operation.unlock();
           }         
       }
       mutex_game_operation.unlock(); 
       return status;
    }    
};

/* Initialize the static member */
GameManager* GameManager::instance = NULL;

/* REST API wrappers for the functionalities */

/* Create a new player, and return the id of the new player created */
int tictacserver::create_new_player()
{
   return GameManager::inst()->create_new_player();
}

/* Create a new game, and return the id of the new player created */
string tictacserver::create_new_game()
{
   int gameid = GameManager::inst()->CreateNewGame();
   return "Successfully created New Game ID:"+to_string(gameid);
}

/* Get the ids and won games for all players */
unordered_map<int,int> tictacserver::GetPlayerInfo()
{
   return GameManager::inst()->players();
}

/* make a move for a particular game */
string tictacserver::move(int gameid,int playerid,int row,int col)
{
  string responsemessage ="Correctly Played by Player ID "+to_string(playerid);
  cout<<"\n Request received for move. GameId: "<<gameid<<" PlayerId: "<<playerid<<" Row: "<<row<<" Column: "<<col;
  int status = GameManager::inst()->makemove(gameid,playerid,row,col);
  if(status==4)
     responsemessage = "Invalid Player "+ to_string(playerid) +" tried to make a move";
  if(status==3)
     responsemessage = "Sorry, invalid move given by player ID: "+ to_string(playerid);
  if(status==2)
     responsemessage = "Game over, Draw";
  if(status==1 || status==0)
     responsemessage = "Game over, Player "+to_string(GameManager::inst()->GetPlayerFromGame( gameid,status ))+" has won.";
  cout<<"\n Sending response :"<<responsemessage;
  return responsemessage;
}


/* Get the board status for all the games, along with corresponding gameids */
unordered_map<int, vector<vector<char>>> tictacserver::GetAllGames()
{
  return GameManager::inst()->GetAllGames();
}


/* Get the board status for all the games, along with corresponding gameids */
unordered_map<int, vector<int>> tictacserver::GetAllGamesStatus()
{
  return GameManager::inst()->GetAllGamesStatus();
}



